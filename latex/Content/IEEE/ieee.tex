\documentclass[conference]{./IEEEtran/IEEEtran}
\usepackage{color}
\usepackage{listings}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\usepackage{makecell}
\usepackage{enumitem}
\renewcommand\theadfont{\bfseries}
\input{../Preamble/myTables}
\input{../Preamble/myFigures}


\lstset{ %
	backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
	basicstyle=\normalsize,        % the size of the fonts that are used for the code
	breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
	breaklines=true,                 % sets automatic line breaking
	captionpos=b,                    % sets the caption-position to bottom
	commentstyle=\color{mygreen},    % comment style
	deletekeywords={...},            % if you want to delete keywords from the given language
	escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
	extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
	frame=single,	                   % adds a frame around the code
	keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
	keywordstyle=\color{blue},       % keyword style
	language=VHDL,                   % the language of the code
	morekeywords={*,...},            % if you want to add more keywords to the set
	numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
	numbersep=9pt,                   % how far the line-numbers are from the code
	numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
	rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
	showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
	showstringspaces=false,          % underline spaces within strings only
	showtabs=false,                  % show tabs within strings adding particular underscores
	stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
	stringstyle=\color{mymauve},     % string literal style
	tabsize=2,	                   % sets default tabsize to 2 spaces
	title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}
% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)

% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
	\usepackage[pdftex]{graphicx}
% declare the path(s) where your graphic files are
	\graphicspath{{../../Figures/}}
	\DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
% or other class option (dvipsone, dvipdf, if not using dvips). graphicx
% will default to the driver specified in the system graphics.cfg if no
% driver is specified.
	\usepackage[dvips]{graphicx}
% declare the path(s) where your graphic files are
	\graphicspath{{../eps}}
% and their extensions so you won't have to specify these with
% every instance of \includegraphics
	\DeclareGraphicsExtensions{.eps}
\fi
\usepackage[nolist]{acronym}

\usepackage[outdir=./]{epstopdf}
%\setcounter{secnumdepth}{0}
\begin{document}
	\begin{acronym}
		\acro {BLE} {Bluetooth Low Energy}
		\acro {SIG} {Special Interest Group}
		\acro {BR/EDR} {Basic Rate/Enhanced Data Rate}
		\acro {IoT} {Internet of Things}
		\acro {COTS} {commercial-off-the-shelf}
		\acro {CI} {critical infrastructure}
		\acro {WSN} {Wireless Sensor Network}
		\acro {ATT} {Attribute Protocol}
		\acro {GATT} {Generic Attribute Profile}
		\acro {SM} {Security Manager}
		\acro {LTK} {Long Term Key}
		\acro {CSRK} {Connection Signature Resolving Key}
		\acro {IRK} {Identity Resolving Key}
		\acro {AES} {Advanced Encryption Standard}
		\acro {TK} {Temporary Key}
		\acro {STK} {Short-Term Key}
		\acro {ECDH} {Elliptic Curve Diffie Hellman}
		\acro {CE} {Connection Events}
		\acro {CRC} {Cyclic Redundancy Check}
		\acro {SCA} {sleep clock accuracy}
		\acro {RSSI} {Received Signal Strength Indicator}
		\acro {MAC} {Media Access Control}
		\acro {CRM} {Customer Relationship Management}
		\acro {BSSID} {basic service set identifier}
		\acro {SSID} {service set identifier}
		\acro {AP} {access point}
		\acro {CSV} {comma-separated values}
		\acro {API} {application programming interface}
		\acro {MPDU} {\ac{MAC} Protocol Data Unit}
		\acro {FSize} {frame size}
		\acro {CITIoT} {Classification, Identification, Tracking of IoT}
		\acro {WPA2-PSK} {Wi-Fi Protected Access 2 - Pre-Shared Key}
		\acro {OUI} {Organizationally Unique Identifier}
	\end{acronym}
\title{Data Leakage in Smart Homes}

% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{\IEEEauthorblockN{Steven M. Beyer}
	\IEEEauthorblockA{
		Air Force Institute of Technology\\
		Wright-Patterson AFB, OH 45433\\
		Email: steven.beyer@afit.edu}
	\and
	\IEEEauthorblockN{Barry E. Mullins}
	\IEEEauthorblockA{
		Air Force Institute of Technology\\
		Wright-Patterson AFB, OH 45433\\
		Email: barry.mullins@afit.edu}
	\and
	\IEEEauthorblockN{Scott R. Graham}
	\IEEEauthorblockA{
		Air Force Institute of Technology\\
		Wright-Patterson AFB, OH 45433\\
		Email: scott.graham@afit.edu}}

% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract
\begin{abstract}
	As smart home technologies become more popular, the increased prevalence of \ac{BLE} and Wi-Fi devices in the home necessitates the need for consumers to be aware of the privacy information these devices inadvertently broadcast and take measures to defend against leakage. These protocols are increasingly used in a range of \ac{IoT} devices such as security cameras, locks, and sensors. Two characteristics of these devices leave them vulnerable to privacy leakage: (i) these devices continuously broadcast unencrypted information, such as \ac{MAC} addresses (Wi-Fi) or device name (\ac{BLE}), which anyone with a properly-tuned receiver can observe, and (ii) the implementation of \ac{BLE} security is left up to the developer and often results in essentially no link layer authentication or encryption.
	
	This work shows how vulnerabilities enable an eavesdropper to collect data from devices without being connected to the smart home environment. The information can then be used to identify devices, track user's movements, and deduce events such as when a door is opened or when a light is turned on.  
	
	To demonstrate these capabilities, we developed a voice activated digital assistant and \ac{IoT} architecture by integrating a variety of off-the-shelf Wi-Fi and \ac{BLE} devices with Apple's home automation application, HomeKit. Furthermore, we created a device classifier and pattern-of-life analysis tool, CITIoT (Classify, Identify, and Track Internet of Things), that was able to classify devices in the smart home architecture with a mean accuracy of ~94\%, identify 95\% of all events over a 5 day period, and track when users are home or away with 100\% accuracy. We also show how it is possible to piece together the sniffed information to track occupants of a house and crack a Bluetooth lock. Lastly, we present how a user can take advantage of the limitations to this approach and security recommendations to defend against these vulnerabilities and create a more secure smart home environment.
	
\end{abstract}
\acresetall
\section{Introduction}
In recent years, smart home devices have become one of the most popular categories in the \ac{IoT} accounting for \$3.5 billion of a \$292 billion industry; over 29 million smart home devices are expected to ship in 2017, a 63 percent increase over 2016 \cite{consumerTech}. Wi-Fi and \ac{BLE} are two of the primary protocols used in these devices and are commonly implemented in security cameras, locks, medical devices, sensors, and a myriad of other devices. With the increasing prevalence of \ac{BLE} and Wi-Fi devices in the home, consumers must be aware of the information these devices inadvertently broadcast and what kind of privacy data an outside observer can infer. 

This work contributes to the field of \ac{IoT} security, specifically privacy within a smart home, by illustrating how devices leak data and demonstrating how users can prevent leakage. In doing so, we make four principal contributions:

\textbf{Smart home architecture}. To analyze \ac{IoT} data leakage in the wild, we provide a realistic smart home architecture that integrates Wi-Fi and \ac{BLE} \ac{COTS} devices with Apple's home automation application, HomeKit.

\textbf{Vulnerability analysis.} We explain how an eavesdropper can use device vulnerabilities, characteristic data exchanges, and packet sizes to create a classifier able to identify components of the smart home environment.

\textbf{\ac{CITIoT}.} We present a tool that demonstrates four capabilities enabled by data leakage: network mapping, device classification, event identification, and user tracking.

\figSmartHomeArchitecture

\textbf{Synthesis.} We stress the importance of smart home operational security by demonstrating how \ac{CITIoT} can be used to gain access to a smart home when a user is away.

The rest of this paper is organized as follows: Section~\ref{background} discusses background and related research in the areas of Wi-Fi and \ac{BLE} security and \ac{IoT} device privacy. Section~\ref{smartHome} presents the smart home architecture used in creating and evaluating \ac{CITIoT}. Sections~\ref{classifier} and~\ref{citiot} describe the creation of the device classifier and how it is used by \ac{CITIoT} to classify devices, identify events, and track users. Section~\ref{results} reports \ac{CITIoT}'s accuracy on the smart home architecture. Finally, the implications of device data leakage are discussed and methods to defend against these attacks are presented in Section~\ref{synthesis} before the paper is concluded in Section~\ref{conclusion}

\section{Background and Related Research}\label{background}

The 802.11 wireless specification defines the physical and link layers for communication in the 2.4 GHz radio band \cite{802.11}. It also defines security procedures to encrypt data within a wireless network. Even with encryption, however, Wi-Fi still transmits a subset of information in the clear within the \ac{MPDU} data frame. Values of interest in this frame include source, destination, and wireless router \ac{MAC} addresses. Also, the time, size, and \ac{RSSI} of each packet can be ascertained by the receiver wireless network card. While these values are necessary for communication at lower levels of the Wi-Fi protocol, researchers have taken advantage of values sent in the clear to eavesdrop privacy information about users. For example, researchers have used \ac{MAC} addresses and \ac{RSSI} values to create location tracking systems on campuses \cite{Zhou}, track crowds at mass events \cite{Bonne}, and in \ac{CRM} allowing commercial businesses to track stores visited by customers \cite{Atkinson}. Researchers in the United Kingdom were able to use \ac{FSize} and packet times to fingerprinting applications used on mobile phones \cite{Atkinson}.

The Bluetooth \ac{SIG} introduced \ac{BLE} in Bluetooth Core Specification v4.0 \cite{sig4.0}. \ac{BLE} is designed to minimize power, cost, and data rate; these goals are accomplished by limiting overhead at every level of the architecture and using simple communication protocols. The \ac{BLE} specification defines security procedures to encrypt the payload, generate private addresses, and provide authentication in its \ac{SM} \cite{sig4.2}. However, implementation of security is left up to designers and each additional security measure contributes to increased energy consumption \cite{Heydon}. Poor \ac{SM} implementation has left these devices vulnerable to privacy leakage and security vulnerabilities. For example, in a few recent studies focused on \ac{BLE} wearable fitness trackers researchers were able to use messages sent from devices to determine activity level and gait of users \cite{Das}, while another group tracked a user wearing a Fitbit up to 1,000 meters away \cite{RoseTrack}. Likewise, poorly implemented \ac{SM}s enabled researchers to crack 12 \ac{BLE} locks from up to a quarter mile away \cite{RoseLocks}.	

While research has been done in the realm of Wi-Fi and \ac{BLE} privacy leakage, this is the first work providing a broad review of privacy leakage from smart home devices in the wild and methods to secure smart homes.

\section{Smart Home Architecture}\label{smartHome}
As shown in Figure~\ref{fig:SmartHomeArchitecture}, the smart home architecture includes three controller components and various connected devices. The controller components include (i) a Raspberry Pi running the Homebridge server that emulates the iOS HomeKit \ac{API} and exposes supported devices to Apple's HomeKit, (ii) an iPhone 6+ running Apple's HomeKit and device specific applications, and (iii) an Apple TV Generation 2 acting as a smart home hub to allow access to HomeKit supported devices while the user is away from the smart home. The communication between controllers and devices can be observed in Figure~\ref{fig:SmartHomeArchitecture} and is described in the rest of this section.

The Raspberry Pi 3 Model B with Raspbian Jessie Lite version 4.9 operating system is connected to the smart home network via the on-board 802.11 b/g/n 2.4 GHz wireless chip \cite{rasbperry}. The Raspberry Pi runs Homebridge version 0.4.14 as a systemd service, and each interaction between a controller and device is logged in the systemd journal \cite{homebridge}. A Homebridge module is utilized to expose Belkin devices to Apple's Homekit and is loaded into Homebridge \cite{wemo}. The Apple devices communicate via the Raspberry Pi to interact with the Wi-Fi devices (devices w$ _2 $-w$ _9 $ in Table~\ref{tbl:WifiDevicesShort}).

The iPhone 6+ and Apple TV act as controllers in the smart home architecture and connect to devices via Wi-Fi and \ac{BLE}. When the user is home, the iPhone connects to Wi-Fi devices via the Homebridge and directly to \ac{BLE} devices. Some of the \ac{BLE} devices are not supported by Apple's Homekit and can only be accessed through the manufacturer-provided iOS application on the iPhone (devices b$ _7 $-b$ _{11} $ in Table~\ref{tbl:BtleDevicesShort}). When the user is away from the smart home, the iPhone can communicate with Homekit-supported devices via the iCloud and Apple TV acting as a hub. For example, if the user is away from home and wants to access the temperature in a room, the iPhone communicates with the Apple TV via the iCloud and the Apple TV will communicate with the device in the home via Wi-Fi or \ac{BLE}. This will only work with Homekit supported devices, therefore, \ac{BLE} devices b$ _7 $-b$ _{11} $ cannot be accessed while the user is away from the home. 

To facilitate Wi-Fi communication in the smart home architecture, a 2.4 GHz Wi-Fi \ac{AP}, ``Prancing Pony", was setup with \ac{WPA2-PSK} security on channel 1. A list of devices connected to the \ac{AP} can be found in Table~\ref{tbl:WifiDevicesShort}. The smart home devices include a camera, six outlets (four smart plugs, one mini plug, and one energy plug), and a motion sensor (w$ _2 $-w$ _9 $). These devices use the Homebridge to communicate with Apple's HomeKit on the iPhone. 

For \ac{BLE} communication to occur in the smart home architecture, a \ac{BLE} master must be present. In the smart home architecture, the iPhone and Apple TV act as masters while each of the \ac{BLE} devices are slaves. A list of devices operating in the \ac{BLE} can be found in Table~\ref{tbl:BtleDevicesShort}.

\tableWifiDeviceShort

\section{Building the Classifier}\label{classifier}

This section describes the process used to build a classifier that can identify Wi-Fi \ac{IoT} devices and events. To emulate the scenario in which the classifier operates, each device in Table~\ref{tbl:WifiDevicesShort} was activated over two 10-hour days within the smart home environment.  Wireless packets were collected using an 802.11ac wireless adapter (Alfa Card AWUS036ACH) in monitor mode and an open source sniffing tool (Airodump-ng). The file captures were decrypted using the network passkey to allow analysis of traffic. These packets were then analyzed using a 4-tuple that includes packet arrival time, \ac{FSize}, and the unencrypted information sent within the \ac{MPDU} (source and destination \ac{MAC} addresses). For device identification, these 4-tuples were sorted by destination address (i.e., when the iPhone sends an event request to a smart home device). By observing traffic over the 2-day period, clear criteria were created to classify devices into one of three categories: electrical outlet, sensor, or camera. Outlets are the only devices to receive packets with \ac{FSize} greater than 600 bytes, sensors never receive a packet with \ac{FSize} greater than 275 bytes, and cameras are the only devices to receive packets between 275 and 300 bytes. Therefore, the classifier measures each device by these criteria and categorizes them accordingly.

Event identification relies on successful device classification and must wait until the first step is complete. For electrical outlets, the classifier utilizes the same 4-tuple sorted by destination address to identify when a user turns on or off the outlet. From traffic analysis, outlets are controlled using a HTTP POST command with a packet size of 620 bytes when encrypted. Each outlet event is identified via that criteria. Unlike outlets, however, sensors and cameras transmit information (e.g., camera snapshots or motion notifications) to the controller in short bursts at the time of an event; a slightly different approach is used for these devices: each packet's 4-tuple is sorted by source address and the outgoing \ac{FSize} are aggregated in 1-minute segments. Camera events are identified by a combined \ac{FSize} greater than 100,000 bytes, while motion events occur between 10,000 and 100,000 bytes. Table~\ref{tbl:DeviceClassifier} summarizes the criterion used for device classification and event identification.

\tableBtleDeviceShort
\tableDeviceClassifier

\section{\ac{CITIoT} Tool}\label{citiot}

To illustrate the operation of CITIoT, we provide the following scenario: a user is in a smart home connected to a Wi-Fi \ac{AP} and interacts with various Wi-Fi and \ac{BLE} \ac{IoT} devices. In the morning, the user turns on lights, activates sensors while walking throughout the house, and eventually turns off the lights before leaving the house for work (the door is locked before leaving). While at work, the user checks on the temperature in the house or other devices (e.g., security cameras) remotely. After work, the user returns home, unlocks the front door, turns on lights, and activates sensors throughout the house. Before going to bed, the lights are turned off. During the day, an observer is outside the house sniffing wireless data packets attempting to infer information about the user, devices, and events within the house. The observation process is completely passive and, therefore, undetectable by the user. The eavesdropper has no access to  network credentials and is not part of the smart home network. 

CITIoT operates in five-steps: (i) reconnaissance and scanning, (ii) passive sniffing, (iii) device classification, (iv) event identification, and (v) user tracking. The remainder of this section describes the operation of CITIoT in regards to the scenario and smart home architecture described above.

\subsection{Reconnaissance and Scanning}

The first step is to identify the target walking out of the home using a directional antenna, an Alfa Card, and Airodump-ng. As the target is still connected to the smart home \ac{AP}, the adversary is able to obtain the target's \ac{MAC} address, associated router address, and \ac{SSID} of the smart home. Next, the adversary scans for devices connected to the smart home by using the sniffing tool while filtering on the target router \ac{MAC} address. The list of device \ac{MAC} addresses obtained from this scan are inputed into an \ac{OUI} lookup tool to identify device manufacturers. Using this information, it can be inferred which are \ac{IoT} devices (e.g., Belkin devices) and which are controllers (e.g., Raspberry Pi or Apple devices). Similarly, a Bluetooth wireless adapter (Plugable USB 2.0)  and sniffing tool (BlueZ \cite{Bluez}) are used to scan for \ac{BLE} devices. The adversary then scans Wi-Fi traffic to develop a Wi-Fi network map using the network mapping tool in CITIoT. The network mapping tool parses the capture file for the source, destination, and \ac{FSize} of each packet to build correlations between devices; Figure~\ref{fig:NetworkMapping} shows the output mapping for the smart home architecture with thicker lines indicating that more data is transmitted between these devices.

\figNetworkMapping

\subsection{Passive Sniffing}

After reconnaissance and scanning, the eavesdropper collects wireless data from the smart home. The Alfa Card is used to collect Wi-Fi traffic, and the sniffing tool is set to filter on the target router \ac{MAC} address and associated wireless channel. Three Ubertooth Ones (Firmware: 2017-03R2 \cite{Ubertooth}) are used to collect \ac{BLE} traffic and are set to follow connections. All of these sniffers can be used on a Raspberry Pi with the proper tools installed, using a battery pack for power, and concealed outside of the target house. The sniffers are left on for the duration of the scenario. At the end of the day, the adversary transfers the capture files from the Raspberry Pi either remotely or by retrieving the Raspberry Pi. The Wi-Fi capture files are parsed using Python 2.7.10 and Pyshark 0.3.7.8, a Python wrapper for parsing packets using Wireshark dissectors \cite{Pyshark}. The time, size, source, and destination for each packet are extracted and the resulting 4-tuples stored in a \ac{CSV} file and sent to the classifier. 

\subsection{Device Classification}
Device classification uses the classifier to categorize Wi-Fi devices into one of three groups: sensor, electrical outlet, or camera. A Python script iterates the \ac{CSV} file of 4-tuples and passes each packet to the classifier until one meets the criteria and the device is identified. The output of this step is a \ac{CSV} file with the \ac{MAC} address and type for each device. The \ac{BLE} capture files are parsed using Python and Pyshark to locate each advertisement and scan response packet and create a list of devices and names stored in a \ac{CSV} file.

\subsection{Event Identification}
After device classification, events are identified. For Wi-Fi, the \ac{CSV} file of 4-tuples is parsed and each packet is passed to the classifier. Using the device types and classifier criteria, events are identified. The resulting output is a list of Wi-Fi events with time, source, and destination for each day. \ac{BLE} events are identified by parsing the capture for connection events. The resulting time, source, and destination of each event is stored in a \ac{CSV} file.

\subsection{User Tracking}
User tracking is accomplished by noting the times of messages sent by devices within the Wi-Fi network. A device that does not send any messages for more than five minutes is considered to be away from the network. Timing begins at the start of the scenario and ends when the scenario is complete.

\section{Results}\label{results}
\figDataCollectionFramework
\ac{CITIoT} was evaluated while a user interacted with the smart home environment ten hours a day for five days. The user interacted with devices while home in the morning and evening, and while away in the afternoon. During the interactions, the user recorded the time, device, and type of each event. Each device was activated twice in the morning, twice in the evening, and a couple times throughout the day for a total of more than thirty activations per device over the week. As seen in Figure~\ref{fig:DataCollectionFramework}, the accuracy of \ac{CITIoT} was analyzed by the comparison of device classification with actual device types, event identification with the event logs, and user tracking with actual user locations. Findings are summarized in Tables~\ref{tbl:WifiResults} and~\ref{tbl:BleResults} and discussed in the rest of this section.  

In step one, reconnaissance and scanning successfully identified the manufacturer of each Wi-Fi device in Table~\ref{tbl:WifiDevicesShort}, correctly mapped the Wi-Fi network, and identified 10 out of 13 \ac{BLE} devices listed in Table~\ref{tbl:BtleDevicesShort}. The two Apple devices and bike lock do not advertise their device names and were not identified. In step two, sniffing was successful all but one day when the \ac{BLE} sniffers failed and no data was collected. A total of 6.5 GB and 43.4 million packets were captured throughout the experiment. In step three, device classification was 94\% successful with all 8 Wi-Fi devices and 9 out of 10 \ac{BLE} devices categorized each day. On average, step four was 94\% successful in identifying events (true positives). CITIoT failed to identify 6\% of events (false negatives) and identified 3 events (false positives) per day that did not actually occur. False positives and negatives were observed in both Wi-Fi and \ac{BLE}. For Wi-Fi, dropped packets accounted for all failures in event identification. Drops can be expected as the Alfa Card is sniffing passively and there is no method to recover from or identify a dropped packet. Each false positive was caused by the camera or the motion sensor. This was due to the method of aggregation of sent packets within a minute. Enough packets were collected in that minute to break the classifier threshold. These packets appeared to be control responses sent from the devices to the controller. For \ac{BLE}, dropped or malformed packets accounted for most of the failures in event identification. If a connection request packet is dropped by the Ubertooth One, the sniffer cannot follow the connection and CITIoT will not identify an event. Two event identification failures were due to the Ubertooth only being able to follow one connection at a time; if the Ubertooth is following a different connection and an event occurs, that event will be ignored. \ac{BLE} false positives occur if a device connects to the controller to pass status information (e.g., battery status). CITIoT assumes every connection is an event and will wrongly identify these connections as events. Step five was 100\% successful in determining if the user was in the home or not. 

\tableWifiResults
\tableBleResults

\section{Synthesis}\label{synthesis}

\subsection{Putting It All Together}

Using the results from CITIoT we were able to make a few observations about the user and smart home that have security implications: (i) the user was away from the home from 0800-1100 four days out of the week, (ii) the user used a \ac{BLE} lock to secure their home, and (iii) the user has a Wi-Fi based security camera and motion sensor in their home. The event identifications point to times in the packet capture when the \ac{BLE} lock was used, and by examining that traffic more closely we were able to observe that the communication between the user and the lock was not encrypted and passwords were sent in the clear. Using this information, we were able to change the user and administrator password or unlock the lock at will. With the knowledge of when the user is away from the home an adversary can predict a good time to attempt to gain access to the smart home. The adversary also knows to be aware of a Wi-Fi camera and sensor.

\subsection{Recommendations to Manufacturers and Users}
Many of the vulnerabilities used in this work take advantage of information that is not encrypted at the lower levels of the Wi-Fi and \ac{BLE} protocols, therefore, to create more secure smart home devices, developers must consider security from the physical layer on up. For Wi-Fi, this includes periodically changing \ac{MAC} addresses, randomizing \ac{FSize}, and encrypting lower-layer data packets. M. Gruteser and D. Grunwald provide a framework to change \ac{MAC} addresses frequently while still maintaining wireless connectivity \cite{Gruteser}. The technique of ``chaffing and winnowing," as introduced by R. Rivest, can be adapted in smart home technologies to send secure packets intertwined with fake packets of random size to make events impossible to identify \cite{Rivest}. In \ac{BLE}, devices need to make their advertisements private. K. Fawaz et al., designed an authentication system, \ac{BLE}-Guardian, that restricts who can discover, scan, and connect to \ac{BLE} devices that would greatly increase the security of smart home devices \cite{Fawaz}. Also, common operational security methods will help prevent against smart home device attacks. For example, users should be aware that routine schedules leave them vulnerable to pattern-of-life modeling-- a threat which is increased by smart devices. Maintaining unpredictable schedules will help prevent attacks. Similarly, turning on or off lights while away from home can trick an observer into thinking someone is home. It is also important to have situational awareness of potential eavesdroppers or suspicious devices around when accessing smart locks or other devices.

\subsection{Vulnerability Drivers}

While the recommendations in the previous section can improve the security of smart home environments, none of these ideas are new. Why, then, have these fixes not been implemented to secure against privacy leakage? In response to rapid growth of the \ac{IoT} market, efforts to limit power, develop devices quickly, and other design constraints drive developers toward poor security implementation, leaving devices vulnerable. Also, while the areas of network and computer security have seen more adversarial pressure, the smart home is relatively new. Until recently, outlets, locks, and light-bulbs were not connected to networks. This is the same evolution of vehicles as they become connected to the Internet and, therefore, open to attack. The privacy implications demonstrated in this work, however, require that developers of \ac{IoT} technologies consider security in design and engage with the computer security community to create more secure smart homes.

\subsection{Limitations and Future Work}

Limitations exist that can enable consumers to mitigate some of the attacks presented in this work. For example, the \ac{BLE} lock attack relies on poor \ac{SM} implementation than can be mitigated with software updates. Similarly, if a consumer does thorough research into device security and makes purchases from reputable manufacturers, vulnerabilities are less likely to exist. Also, only a limited selection of Wi-Fi devices were used in training the classifier in \ac{CITIoT} and only one smart home architecture was tested. If a smart home designer integrated different controllers and devices into the smart home it would further degrade CITIoT's capabilities as it is not trained for those environments or devices. For future work, an analysis of more devices and architectures should be carried out to examine if similar fingerprinting methods can be used and vulnerabilities exist in other devices. Also, other tools can be added to CITIoT, such as location tracking, to further stress the security implications of smart home devices. Additionally, implementation of the above security recommendations on open-source smart home devices can significantly further research in the security of smart home devices.

\section{Conclusion}\label{conclusion}
As the modern home gets smarter it also becomes more vulnerable to attacks that were reserved to computers and networks. \ac{IoT} devices constantly communicate data that enable an eavesdropper to infer information about people and devices within a smart home. Users must be aware of what their devices are advertising and how this information can be used against them. This work informs the consumer by presenting a real-world smart home architecture and how an eavesdropper can use CITIoT to learn the types of \ac{IoT} devices within the home, how they are networked, when events occur in the house, and when someone leaves. We demonstrated how this information can point an attacker to a vulnerable device such as a \ac{BLE} lock, inform when the users will not be home, and identify what kind of security devices are in the home. After presenting the security implications of smart homes, we recommended ways manufactures and users can defend against these vulnerabilities and how future work can expand on these findings to create a more secure smart home.

%\begin{flushleft}
%	\singlespace
%	\bibliographystyle{plain}
%	\bibliography{../Back/myReferences} 
%	\clearpage
%\end{flushleft}
\begin{thebibliography}{1}
	
	\bibitem{consumerTech}
	Consumer Technology Association. (2017). ``Record Year Ahead: Consumer Enthusiasm for Connectivity to Propel Tech Industry to Record-Setting Revenues" [Online]. Available: www.cta.tech/News/Press-Releases/2016/January/Record-Year-Ahead-Consumer-Enthusiasm-for-Connect.aspx, [Last accessed Aug 27, 2017].
	
	\bibitem{802.11}
	{\em Wireless LAN Medium Access Control, MAC, and Physical Layer, PHY, Specification}, IEEE Standard 802.11, 2016. Available: standards.ieee.org/about/get/802/802.11.html, [Last accessed Aug 27, 2017]
	
	\bibitem{Zhou}
	M. Zhou et al., ``SCaNME: Location tracking system in large-scale campus Wi-Fi environment using unlabeled mobility map," in {\em Expert Systems with Applications}, vol. 41, no. 7, pp. 3429-3443, Oct. 2014.
	
	\bibitem{Bonne}
	B. Bonne et al., ``WiFiPi: Involuntary tracking of visitors at mass events," in {\em IEEE 14th International Symposium on a World of Wireless, Mobile and Multimedia Networks}, Madrid, Spain, 2013, pp. 1-6.
	
	\bibitem{Atkinson}
	J.S. Atkinson et al., ``Your WiFi is leaking: What do your mobile apps gossip about you?" {\em Future Generation Computer Systems}, May 2016.
	
	\bibitem{sig4.0}
	{\em Specification of the Bluetooth System}, Core Version 4.0, June 30, 2010. Available: www.bluetooth.com/specifications/bluetooth-core-specification, [Last accessed Aug 27, 2017].
	
	\bibitem{sig4.2}
	{\em Specification of the Bluetooth System}, Core Version 4.2, December 2, 2014. Available: https://www.bluetooth.com/specifications/bluetooth-core-specification/legacy-specifications, [Last accessed Aug 27, 2017],
	
	\bibitem{Heydon}
	R. Heydon, {\em Bluetooth Low Energy: The Developer's Handbook}. Crawfordsville, IN: Pearson Education, Inc., 2013.
	
	\bibitem{Das}
	A. Das et al., ``Uncovering Privacy Leakage in BLE Network Traffic of Wearable Fitness Trackers," in {\em Proceedings of the 17th International Workshop on Mobile Computing Systems and Applications}, St. Augustine, FL, 2016, pp. 99-104.
	
	\bibitem{RoseTrack}
	A. Rose et al., ``Bluefinder: A range-finding tool for Bluetooth classic and low energy," in {\em Proceedings of the 12th International Conference on Cyber Warfare and Security}, Dayton, OH, 2017, pp. 303-311.
	
	\bibitem{RoseLocks}
	A. Rose and B. Ramsey. (2016). ``Picking Bluetooth Low Energy locks from a quarter mile away" [Online]. Available: media.defcon.org/DEF\%20CON\%2024/DEF\%20CON\%2024\%20presentations/, [Last accessed on Aug 30, 2017].
	
	\bibitem{rasbperry}
	Raspberry Pi Foundation. (2016). ``Raspberry Pi 3 Model B Specifications" [Online]. Available:  raspberrypi.org/products/raspberry-pi-3-model-b/, [Last accessed on Aug 30, 2017].
	
	\bibitem{homebridge}
	nfarina. (2015). ``Homebridge" [Online]. Available: github.com/nfarina/homebridge/, [Last accessed on Aug 30, 2017].
	
	\bibitem{wemo}
	devbobo. (2017). ``homebridge-platform-wemo" [Online]. Available: npmjs.com/package/homebridge-platform-wemo/, [Last accessed on Aug 30, 2017].

	\bibitem{Bluez}
	BlueZ. (2016). {\em BlueZ, Official Linux Bluetooth Protocol stack} [Online]. Available: bluez.org, [Last accessed on Aug 27, 2017].

	\bibitem {Ubertooth}
	Ubertooth. (2017). {\em greatscottgadgets} [Online]. Available: github.com/greatscottgadgets/ubertooth/, [Last accessed on Sep 5, 2017].
	
	\bibitem{Pyshark}
	Pyshark. (2017). {\em KimiNewt} [Online]. Available: github.com/KimiNewt/pyshark, [Last accessed on Aug 27, 2017].
	
	\bibitem{Gruteser}
	M. Gruteser and D. Grunwald, ``Enhancing location privacy in wireless LAN through disposable interface identifiers: a quantitative Analysis," in {\em Mobile Networks and Applications}, vol. 10, no. 3, pp. 315-325, Jun. 2005.
	
	\bibitem{Rivest}
	R. Rivest. ``Chaffing and winnowing: Confidentiality without encryption" in {\em CryptoBytes (RSA laboratories)}, vol. 4, no. 1, pp. 12-17, 1998.
	
	\bibitem{Fawaz}
	K. Fawaz et al., ``Protecting privacy of \ac{BLE} device users" in {\em USENIX Security Symposium}, Austin, TX, 2016, pp. 1205-1221.
	
	
	
	
	
	


	
\end{thebibliography}


\end{document}