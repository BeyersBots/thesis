\documentclass[12pt,letterpaper,oneside]{book}
\usepackage{../../afitStyleFiles/afitThesis}
\usepackage[nolist]{acronym}
\usepackage{todo}
\usepackage{tabu}
\usepackage{makecell}
\graphicspath{{../../Figures/}}
\input{../Preamble/myFigures}
\input{../Preamble/myTables}
\usepackage[outdir=./]{epstopdf}

\begin{document}
	\begin{acronym}
		\acro {BLE} {Bluetooth Low Energy}
		\acro {SIG} {Special Interest Group}
		\acro {BR/EDR} {Basic Rate/Enhanced Data Rate}
		\acro {IoT} {Internet of Things}
		\acro {CI} {critical infrastructure}
		\acro {WSN} {Wireless Sensor Network}
		\acro {ATT} {Attribute Protocol}
		\acro {GATT} {Generic Attribute Profile}
		\acro {SM} {Security Manager}
		\acro {LTK} {Long Term Key}
		\acro {CSRK} {Connection Signature Resolving Key}
		\acro {IRK} {Identity Resolving Key}
		\acro {AES} {Advanced Encryption Standard}
		\acro {TK} {Temporary Key}
		\acro {STK} {Short-Term Key}
		\acro {ECDH} {Elliptic Curve Diffie Hellman}
		\acro {CE} {Connection Events}
		\acro {CRC} {Cyclic Redundancy Check}
		\acro {SCA} {sleep clock accuracy}
		\acro {RSSI} {Received Signal Strength Indicator}
		\acro {MAC} {Media Access Control}
		\acro {CRM} {Customer Relationship Management}
		\acro {SSID} {Service Set Identifiers}
		\acro {AP} {access point}
		\acro {CITIoT} {Classify, Identify, and Track \ac{IoT}}
		\acro {COTS} {commercial off-the-shelf}
		\acro {MPDU} {\ac{MAC} Protocol Data Unit}
		\acro {FSize} {Frame Size}
		\acro {SHAA} {Smart Home Automation Architecture}
		\acro {MIoTL} {Mitigation of \ac{IoT} Leakage}
		\acro {WPA} {Wi-Fi Protected Access}
	\end{acronym}
\mainmatter
	\acresetall
	\chapter{Background and Related Research}
	
		\section{Overview}
		This chapter provides a technical summary of the Wi-Fi and \ac{BLE} protocols as they pertain to the work presented in this thesis. It also provides a brief overview of other comparable wireless protocols. It follows with an outline of the current state of \ac{IoT} and smart home security, survey of open-source tools used in this work, and discussion of related research.
		
		\section{Wireless Protocols}
			\subsection{Wi-Fi}
			The 802.11 wireless specification defines the physical and link layers for communication in the 2.4 GHz radio band \cite{802.11}. The 802.11 architecture contains four major physical components: (i) access points, (ii) wireless medium, (iii) stations (devices), and (iv) distribution systems (i.e., router) \cite{kurose}. In a typical home Wi-Fi network, the \ac{AP} and router are combined into one unit which is used to connect the network to the Internet. During setup of a secure network, such as the one analyzed in this work, the \ac{AP} is assigned a \ac{SSID}, channel number, and password. Each wireless station must prove knowledge of the password to associate with the \ac{AP} and communicate within the network. Association to a secure network results in the encryption of wireless traffic sent within the network. Figure~\ref{fig:MpduFormat} depicts the frame format for the \ac{MPDU}, the unit of data exchanged between entities using the physical layer (wireless medium). It also shows which portions are encrypted when connected to a secure wireless \ac{AP}. Figure~\ref{fig:MacHeader} provides the fields within the \ac{MAC} Header which include addressing information for Wi-Fi packets at the link layer. Only the first three addresses pertain to this work and indicate the \ac{BSSID}, \ac{SA}, and \ac{DA} \ac{MAC} addresses \cite{802.11}. The \ac{MAC} Header is not encrypted.
			
			\figMpduFormat
			\figMacHeader
			
			In normal operation, \ac{WNIC}s only pass traffic destined to the client station dropping all other packets \cite{kurose}. There are two other modes that select \ac{WNIC}s can operate in which include promiscuous and monitor mode \cite{skoudisCounter}. First, promiscuous mode sets the \ac{WNIC} to pass any traffic with the station's associated \ac{AP} as the \ac{BSSID} of the packets. The second mode, used throughout this work, is monitor mode which sets the \ac{WNIC} to pass any traffic regardless of the \ac{DA} or \ac{BSSID} to the client.
			
			Two other values pertinent to this work include the time of packets and the \ac{FSize}, or packet size. The packet timestamp is calculated by the host kernel, while the receiving application determines the packet size \cite{tcpdump}.
			
			\subsection{\acf{BLE}}
			The Bluetooth \ac{SIG} introduced \ac{BLE} (Bluetooth Smart) in Bluetooth Core Specification v4.0 to complement Bluetooth \ac{BR/EDR} (Bluetooth Classic) \cite{sig4.0}. Although these two implementations share some key attributes (e.g., both operate in the 2.4GHz band and use adaptive frequency hopping), they are different protocols with unique design goals \cite{rHeydon}. While Bluetooth Classic is used in high-bandwidth applications, such as transferring files or streaming audio, \ac{BLE} is designed to minimize power, cost, and data rate. These goals are accomplished by limiting overhead at every level of the architecture and using simple communication protocols. To this same end, \ac{BLE} devices predominantly transmit state data, such as whether a light is on/off, in short, infrequent bursts. These characteristics make \ac{BLE} ideal for \ac{IoT} applications where battery life is a top priority. 
			
			Bluetooth Core Specification v5.0 was adopted in December 2016, however, the majority of commercially-available devices today still use v4.2; this work is focused on devices using v4.2 or older. The rest of this section discusses elements of the \ac{BLE} architecture (shown in Figure~\ref{fig:Architecture}) and protocol which are relevant to the focus of this research.
			
			\figArchitecture
			
				\subsubsection{Attribute Protocol}
				Data is communicated between \ac{BLE} devices in the form of ``attributes" using a client-server architecture ruled by the \ac{ATT}. Each attribute contains state information addressed by a unique handle and type. These attributes are then grouped into characteristics based on discovery method and accessibility. The master device (e.g., smartphones, computers) typically acts as the client, periodically reading/writing information in the form of attributes from/to the server (e.g., locks, sensors) as required by a user. For example, a user (client) may request the status of a door lock using an \ac{ATT} Read Request with the type ``Lock Status" and handle 0x0019; the device (server) then responds with an attribute containing the value ``Unlocked." When the user decides to lock the door, an \ac{ATT} Write Request is sent with the value set as the user's password; if a valid value is provided, the lock changes state to ``Locked." The attack presented in Section~\ref{} of this work uses the \ac{ATT} commands and \ac{GATT} characteristics \ac{BLE} devices use to communicate.
				
				\subsubsection{Security Manager}
				The \ac{SM} defines a process to secure \ac{BLE} connections called pairing and bonding \cite{rHeydon}. When a device wants to create a new connection in which security parameters have not been previously exchanged or have been forgotten, the devices must first establish a trust relationship through the pairing process. While there are application specific ways to implement the \ac{SM}, generally, pairing is accomplished by the devices exchanging pairing information, authenticating each other, encrypting the link, and then sharing keys. Three keys are exchanged during pairing: (i) a shared 128-bit \ac{LTK} used to encrypt future connections with \ac{AES}-128 encryption; (ii) a 128-bit \ac{CSRK} for authentication; and (iii) a 128-bit \ac{IRK} for privacy. After pairing is accomplished, bonding is simply saving the keys for faster connection establishment in the future. If either device loses the encryption keys, the entire pairing and bonding sequence must be re-accomplished. The security of a connection is dependent on how the \ac{SM} is implemented. Many of the devices examined in this work were vulnerable due to poor \ac{SM} implementations that did not enforce encryption or authentication.
				
				\subsection{Physical and Link Layers}
				The physical and link layers control finding devices, establishing connections, packet structure, and transmitting/receiving data. For a connection to occur, one device advertises its presence while another scans. When the scanning device sees the correct advertising device, a connection is created. These advertisements and the overall connection process are key to the work done in observing pattern of life information via \ac{BLE} sniffers. Connections occur between one master and one slave and are broken up into a series of \ac{CE} with the master transmitting packets during a \ac{CE} and each \ac{CE} occurring on a different channel. The connection parameters are set by the master in the connection request packet and include the frequencies to be used and \ac{CE}s interval. Each step of this process is shown in Figure~\ref{fig:Connection} and described below.
				
				\figConnection
				
				\textbf{1- Device Advertises Presence.} A connection begins with a slave announcing its presence by broadcasting advertising packets on three advertisement channels (see Figure~\ref{fig:Channel}). Each advertising packet includes device information such as connectability, scannability, services provided, and name of the device. Advertising packets also include a ``TxAdd" bit that indicates if the advertiser is using a public or random address. A master actively or passively scans the advertisement channels detecting connectible devices. Active scanning is a key concept for the security discussion in this work and the process is depicted in Figure~\ref{fig:Scanning}. When actively scanning, a master observes an advertising packet and, if the device is scannable, sends a scan request to the device. The advertiser sends a scan response back with more information, typically expanding on the device name and possibly including broadcast data such as battery level. A master can only connect to a device that advertises its presence and is connectable.
				
				\figScanning
				
				\textbf{2- Initiator Sends Connection Request.} Once a scanner observes a connectible device, a connection request packet is sent. This packet establishes all of the necessary parameters to start the connection to include the access address, connection interval, transmit window size and offset, hop interval, channel map, and \ac{SCA}. The access address is a random value used to identify packets that are part of the connection. The transmit window, which is calculated using the transmit window offset and size, indicates when the first \ac{CE} will occur. Likewise, the connection interval dictates when each subsequent \ac{CE} will occur. The hop interval and channel map determine which frequencies will be used during the connection. Finally, the \ac{SCA} is vital for synchronization and establishes the amount of time before and after a \ac{CE} the slave must listen to account for any clock drift between the master and slave. The master may update a subset of these parameters at any time in a connection parameter update message. In this message, the master provides a future time at which the new parameters will take effect. To follow a connection, the sniffer used in this work must observe and implement all of the connection parameters and potential changes throughout the connection.
				
				\textbf{3- Hop.} As shown in Figure~\ref{fig:Channel}, the \ac{BLE} frequency band is divided into forty channels separated by 2-MHz. These frequencies are distributed into three advertising channels and thirty-seven data channels. When in a connection, a master and slave communicate on one channel per \ac{CE}. After each \ac{CE}, both the master and slave hop to a new frequency per the Channel Map, Hop Increment, and hopping algorithm; these parameters are established by the master at the beginning of a connection or in a parameter update and are non-negotiable.
				
				\figChannel
				
				\textbf{4- Master Sends Data Packet.} The first data packet sent in a \ac{CE} is called an anchor which establishes the timing for all future \ac{CE}s. A master can send an empty packet to maintain the connection. 
				
				\textbf{5- Slave Responds.} The slave must always respond to a received data packet  from the master unless two consecutive packets are received with an invalid \ac{CRC}. However, to conserve energy, the slave does not have to listen to a predetermined number of \ac{CE}s.
				
				\textbf{6/7- Packets are Sent until Connection Event Ends.} The length of a \ac{CE} is at most the predetermined connection interval, but may be shorter depending on how much data needs to be transmitted. If the slave is listening to the \ac{CE} and responds to the anchor packet, the master and slave exchange packets until a \ac{CE} end condition is met. There are four ways to close a \ac{CE}-- if neither device has more data to send (indicated by the more data bit in the packet); if the more data bit is set and either slave or master do not receive a subsequent packet within 150 $\mu$s; if two consecutive packets are received with an invalid \ac{CRC}; or if the connection interval is reached. There may be multiple \ac{CE}s in one connection; the end of a \ac{CE} does not mean the connection will end. This allows the slave to conserve energy and not listen when no information is sent from the master and the master to send packets to a new device while still maintaining a connection with the initial device. \ac{CE}s can be likened to bursts of data and each \ac{CE} ends at the end of the burst while the overall connection is still maintained.
				
				\textbf{8- Connection Ends.} A connection continues until either device sends a terminate indication packet, if no packets are received within the supervision timeout, or if the message integrity check fails. After a connection ends, the slave resumes advertising its presence.
			
			\subsection{Other Wireless Protocols}
			Other protocols used in \ac{IoT} applications include those based on IEEE 802.15.4 (e.g., ZigBee) and on the ITU-T G.9959 recommendation (e.g., Z-Wave) \cite{Sharma}. These wireless protocols have many of the same privacy leakage issues found in \ac{BLE} and Wi-Fi. Similar to \ac{BLE}, these protocols have proper encryption, but do not encrypt the physical layer \cite{Sharma}. This creates unique security challenges for wireless broadcast networks in which anyone with a properly-tuned receiver can see these data packets. Also, the physical and link layers for each of these protocols inherently advertise legitimate information before and after a connection is established that can be used by an attacker. 
			
			Zigbee advertises \ac{MAC} addresses as well which has been used to infer whether a person is in a room or not \cite{Konings}. Z-Wave provides source, destination, and home identification information that can be used in reconnaissance and device tracking \cite{Badenhop}.
			
			Efforts are being made to provide techniques to limit the amount of data leakage by these protocols. Some examples include periodically changing \ac{MAC} addresses, encrypting lower-layer data packets, and not setting devices in active service discovery mode \ac{SSID}s \cite{Greenstein}. This work seeks to observe and prevent privacy leakage in \ac{BLE} and Wi-Fi through the understanding of \ac{IoT} leakage and design of mitigation tools.
		
		\section{Smart Home Technologies}
		A list of smart home technologies relevant to the work in this paper is provided:
		\begin{itemize}
			\item\textbf{Devices}: \ac{BLE} or Wi-Fi devices such as switches, smart outlets, cameras, or sensors. Devices can be connected to and controlled by controllers.
			\item\textbf{Controllers}: A master device such as an iPhone or Android phone that connects to a device within the smart home to get status updates or change states.
			\item\textbf{Hub}: A system that sits on the home network, connects to different devices via the manufacturer \ac{API}, and exposes control of the devices via a centralized application on the \texttt{controller}. Hubs often provide access to the devices while a user is away from the smart home. Examples of hubs include Apple's HomeKit and the open-source server Homebridge.
			\item\textbf{Apple's HomeKit}: A hub that provides a controller with voice control and automation capabilities for devices.
			\item\textbf{Homebridge}: An open-source server that emulates the iOS HomeKit \ac{API} to expose supported devices to Apple's HomeKit. Added as a hub in the HomeKit, it allows a user to use Siri voice commands to control devices that are not typically supported within HomeKit.
			\item\textbf{Applications}: Many smart home devices require proprietary applications to interact with the device's full range of capabilities. A controller must use these applications to control the device.
		\end{itemize}
		
		\section{Tools}
		Table~\ref{tbl:Tools} provides a list of open-source tools used throughout this work.
		
		\tableTools
		
		\section{Related Research}
		Although Wi-fi and \ac{BLE} smart home devices are becoming commonplace, the privacy leakage and security vulnerabilities of these devices is largely unexplored. In 2016, Ed Skoudis presented a voice controlled and automated \ac{IoT} smart office architecture, J.A.R.V.I.S. \cite{Skoudis}. J.A.R.V.I.S. represents the way forward for smart homes by integrating devices, Apple's Homekit, and automation, but Skoudis admits that security was an afterthought in developing the architecture. At the end of his presentation, Skoudis challenges developers to explore the security implications of the growing \ac{IoT} field. The \acf{SHAA} developed in this work is influenced by Skoudis' work, but extends on it by expanding on the number of devices, including \ac{BLE} devices, and integrating a privacy leakage mitigation method (\ac{MIoTL}). This work also explores the privacy consequences of a smart home architecture such as J.A.R.V.I.S. by analyzing privacy leakage in \ac{BLE} and Wi-Fi devices. 
		
		While the \ac{BLE} specification defines security procedures to encrypt the payload, generate private addresses, and provide authentication \cite{sig4.2}, implementation of the \ac{SM} is left up to the developer; each additional security measure contributes to increased energy consumption \cite{rHeydon}. Limiting power, developing devices quickly, and other design constraints drive developers toward poor implementation of the \ac{SM}, leaving devices with essentially no Link Layer authentication or encryption. 
		
		Recently, oversight in Link Layer security has enabled researchers to crack twelve \ac{BLE} locks from up to a quarter mile away \cite{RoseLocks}. Two man-in-the-middle frameworks were developed due to the lack of Link Layer security that allow home automation denial of service, data manipulation, and command injection \cite{Jourdois}\cite{Slawomir}. The lack of lower-layer security employment also creates vulnerabilities in firmware update procedures; a team of researchers were able to upload customized firmware onto a \ac{BLE} industrial monitor that then provided false sensor readings or locked out legitimate users \cite{GuiterrezIndustrial}. Similarly, a lack of encryption results in unintended privacy leakage. In a few recent studies focused on \ac{BLE} wearable fitness trackers, one group of researchers observed device address and connection information in the clear that enabled them to identify users based off of activity level and gait \cite{Das}, while another group used device addresses and \ac{RSSI} to track a user wearing a Fitbit Surge up to 1,000 meters away with greater than eighty percent accuracy \cite{RoseTrack}. Privacy data has also been used to create pattern mining models to track tourist attraction visits in Belgium to help determine the best locations to put hotels \cite{Versichele}.
		
		Privacy leakage in Wi-Fi has likewise been exploited in recent research. Researchers have used Wi-Fi \ac{MAC} addresses sent in the clear and \ac{RSSI} values to create location tracking systems on campuses, crowd tracking tools at mass events, and in \ac{CRM} allowing commercial businesses to track customer interactions and data \cite{Zhou}\cite{Bonne}\cite{Atkinson}. A group from the United Kingdom were able to use raw Wi-fi signals to create fingerprinting techniques able to identify applications used on a mobile phone \cite{Atkinson}. One researcher was able to use raw Wi-Fi signals to activate alerts when a security camera observes motion \cite{Madrigal}. This research, however, did not look at other types of smart home devices or provide methods of mitigation.
		
		In response to these vulnerabilities, a number of different efforts have been made to increase Wi-Fi and \ac{BLE} security and privacy. For Wi-Fi, this includes periodically changing MAC addresses, randomizing \ac{FSize}, and encrypting lower-layer data packets. M. Gruteser and D. Grunwald provide a framework to change MAC addresses frequently while still maintaining wireless connectivity [18]. The technique of “chaffing and winnowing,” as introduced by R. Rivest, can be adapted in smart home technologies to send secure packets intertwined with fake packets of random size to make events impossible to identify [19]. In \ac{BLE}, devices need to make their advertisements private. Fawaz et al. designed an authentication system, BLE-Guardian, that restricts who can discover, scan, and connect to \ac{BLE} devices \cite{Fawaz}. BLE-Guardian uses jamming techniques to hide advertisements from unauthorized users. It is limited, however, to protecting devices prior to a connection and does not hide packets that are transmitted after a connection is created. As privacy data is still leaked during a connection, much of the reconnaissance information mentioned above can still be collected by an attacker. With BLE-Multi, Gutierrez et al. developed an enhancement to the Ubertooth One \ac{BLE} scanner that enables sniffing of multiple connection simultaneously \cite{GutierrezMulti}. However, the scanner is limited to tracking three connections simultaneously and only saw an eighty-five percent probability of successful packet capture. 
		
		\section{Conclusion}
		This chapter presents a brief technical summary of the Wi-Fi and \ac{BLE} protocols and how their security features relate to those of other comparable wireless protocols. It provides background on key smart home technologies and open-source tools as they pertain to this work. It observes related research into the development of automated smart home architecture, how \ac{BLE} and Wi-Fi properties leave them open to privacy leakage, and current efforts in securing \ac{IoT}. While research has been done in the realm of Wi-Fi and \ac{BLE} privacy leakage, little work has provided a broad review of privacy leakage from smart home devices in the wild or methods to secure smart homes from data leakage. This thesis contributes to the field of \ac{IoT} security, specifically privacy within a smart home, by illustrating how devices leak data and demonstrating how users can prevent leakage through mitigation techniques.
		
		\backmatter
		\singlespace
		\bibliographystyle{plain}
		\bibliography{../Back/myReferences} 
		\clearpage

\end{document}

