The methodology explained in this section is illustrated in Figure~\ref{fig:MethodologyOverview} and expanded on in the following scenario: a user is in her smart home interacting with devices throughout the day. In the morning, she turns on lights, activates sensors while walking throughout the house, and eventually turns off lights before leaving the house for work (she locks her door on her way out). During the day, while at work, she may check on the temperature in the house or other devices remotely. After work, the user returns home, unlocks her front door, turns on lights, and activates sensors throughout the house. Before going to bed she turns off the lights. During the normal usage of the smart home environment, an adversary is outside sniffing packets attempting to infer information about the user, devices, and events within the house. The observation process is completely passive and, therefore, undetectable by the user. The adversary has no access to the network's credentials and is not part of the smart home network. The rest of this section will discuss the process used in CITIoT that allows the observer to infer things about the smart home and is summarized in five primary steps: (i) reconnaissance and scanning, (ii) passive sniffing, (iii) device classification, (iv) event identification, and (v) user tracking.

\figMethodologyOverview

\subsection{Reconnaissance and Scanning}
Outside of the primary capabilities of CITIoT, reconnaissance and scanning is a key component to the overall operation of the tool. Reconnaissance includes selecting the target and observing that target's phone's WiFi \ac{MAC} address. This is a trivial step as the \ac{MAC} address is sent in the clear in every packet from the device and can be sniffed using an Alfa Card with a directional antenna. The next step is to observe which access point in the smart home the phone connects to. Again, this is trivial, as devices send the \ac{SSID} of the \ac{AP} they are connected to in the clear when associated to the \ac{AP}. In our scenario, we observe that the user's phone connects to the \ac{AP} with the SSID ``EC:4F:82:73:D1:1A". Using the open source tool ``airodump-ng" we observe that the SSID is called ``Prancing Pony", it is operating on channel 1, and it has 11 devices connected to it (see Figure~\ref{fig:ReconScanning} for the command and corresponding output). Next, we perform a simple MAC address lookup using Wireshark's OUI Lookup Tool to determine the name of the company that manufactured the network card for each device connected to ``Prancing Pony" (the results can be seen in Figure~\ref{fig:Oui}) \cite{ouiLookup}. 

\figReconScanning
\figOui

The MAC addresses and manufacturers allow the observer to make her first classification: which devices may be controllers (Apple and Raspberry Pi) and smart home devices (Belkin). This information is used to filter traffic in CITIoT. The next four steps occur within CITIoT, are depicted in Figure~\ref{fig:Citiot}, and described below.

\figCitiot

\subsection{Passive Sniffing}

Sniffing is accomplished with three Ubertooth One devices (one for each advertisement channel) for \ac{BLE} packets and an Alfa Card for WiFi packets. The command used to start \ac{BLE} sniffing is shown in Figure~\ref{fig:BleSniffing}. The '-f' flag sets follow mode, the '-U' flag sets which Ubertooth device to use, the '-A' flag sets which advertising channel to listen to, and the '-q' flag outputs the captured files to a PCAP file. At the end of collection, each PCAP is merged to create one \ac{BLE} capture file.

\figBleSniffing

The command used to start WiFi sniffing is shown in Figure~\ref{fig:WifiSniffing}. The '--channel' flag sets which WiFi channel to capture packets on, the '--output-format' flag sets the format type for the capture, the '-w' flag sets the name of the output capture, and the '--bssid' filters packets by \ac{BSSID}.

\figWifiSniffing

After traffic collection is complete a preprocessing script is ran on the WiFi captures to pull out the data needed for classification and identification. As CITIoT makes no attempt to break WiFi encryption and the Data-Link Layer is encrypted, the only information we have access to is from the physical layer. To dissect the PCAP captures into the data of interest, the script utilizes pyshark, a python wrapper based off of Wireshark dissector, tshark \cite{pyshark}. First, the dissector pulls the time, source, destination, and \ac{FSize} for each packet. Then, using the list of smart home devices found above, the script distinguishes between sent and received data for each device. This creates two \ac{CSV} files for each device: one which the device is the source of each packet and the other which the device is the destination of each packet. These \ac{CSV} files are then passed to the device classification unit.

\subsection{Device Classification}

WiFi device classification happens using \ac{FSize} for packets in which the device is the destination. Each packet destined for a specific device is parsed and depending on the trend of packets received (timing, size, and source), the device is classified as either a sensor, outlet, or camera. Figures~\ref{fig:DeviceIdOutlet},~\ref{fig:DeviceIdSensor}, and~\ref{fig:DeviceIdCamera} illustrate classification using a \ac{FSize} distribution created by plotting a histogram for the size of each frame (in bytes) for a given device. Specifically, a packet frame of size greater than 650 bytes is indicative of an outlet, a device that receives no packet frames greater than 275 bytes points to a sensor device, and a device that receives a packet with \ac{FSize} between  275 and 300 bytes is a camera device. These criterion are summarized in Table~\ref{tab:DeviceID}.

\figDeviceId

%\tableDeviceID

Classification of \ac{BLE} devices occur in two stages: first, each device name and address is parsed from advertisement and scan response packets and stored in a local database; and, second, the tool maps all addresses from connection requests with the name from the database. This mapping provides names of devices the user connected to and the times of these connections.

\subsection{Event Identification}

Event Identification occurs after Device Classification and relies on correct classification of devices. Depending on the classification of device, different event thresholds are established. For outlets, the incoming packets' \ac{FSize} are observed (a user turning on or off a device). If the frame is greater than 600 bytes but less than 1000 bytes, then this is an outlet event. For sensors, the outgoing packets' cumulative \ac{FSize} over one second are observed (a motion sensor informing a hub that an event has occurred). From experience, a sensor will send a burst of packets for each motion event with the overall size being greater than 10,000 bytes, but less than 100,000 bytes. A similar method is used for camera events, but these bursts are typically greater than 100,000 bytes. These criterion are summarized in Table~\ref{tab:EventID}.

%\tableEventID

\subsection{User Tracking}

User tracking is based off of device WiFi \ac{MAC} address. The timing of packets sent from a device to any destination are tracked throughout the day. If at any time a device does not send packets for more than five minutes, that device is categorized as being no longer within the home. As soon as the device sends a packet, that device is considered back in the home.